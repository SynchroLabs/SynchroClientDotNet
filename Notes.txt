
Mobile Application As A Service (MAAAS) - Client
=================================================

List bindings
    "items" - context for list of items - should be an array
    "item"  - binding for individual list item (by default, just array element - $data?)
    "selection" - need to be able to specify an item id context (?) - need to be able to r/t selection - selectionId (?) - if empty, use list element value

    Look at how updates are mananged - if not simple string array contents, may want to manage like ListView

ListView

    "items" binding
    "selection" binding
    "itemTemplate" - layout description for each item 
    "onItemClick" command

    ToDo - "item" (defaults to $data) - This is applied to each parent list item to determined the child item to be added to the list (this allows the list item
    to be a context other than the top level enumerated item).

    ToDo - "selectionItem" (defaults to $data) - This is what is placed into "selection" (per item) and this is applied to each item in "items" for the purpose
    of matching list view item with selection items when setting selection state for the list view.  For example, if the selectionItem was "{itemId}", then the
    selection binding would be one or more elements of the "{itemId}" applied to the selected items.  When resetting item selection, "{itemId}" will be applied
    to each list item, and the result will be compared with the value(s) in "selection" to see if the item should be selected.  In the case of the default, the
    selection list will contain deep copies of the list view items, and the selection comparison will be a deep compare of those items with the list view items.

    What about list view header/footer (sections before/after the items)?

    Example (onItemClicked):

        { type: "listview", select: "none", binding: { items: "contacts", selection: "selectedContacts", onItemClick: { command: "itemClicked", item: "{$data}" } }, itemTemplate:
            { type: "stackpanel", orientation: "horizontal", contents: [
                { type: "image", resource: "resources/user.png", height: 50, width: 50 },
                { type: "stackpanel", orientation: "vertical", contents: [
                    { type: "text", value: "{first}" },
                    { type: "text", value: "{last}" },
                ] },
            ] },
        },

        exports.Commands = 
        {
            itemClicked: function(context, session, viewModel, params)
            {
                console.log("Item clicked, first name: " + params.item.first + ", last name: " + params.item.last);
            },
        }

Framework element binding (unregistration)

    Since framework elements can be removed (such as when list view items are removed), and since those framework elements can include
    other framework elements (and so on), we need to maintain a framework element heirarchy, probably via a list of children managed
    in ElementMetaData. We then need an UnregisterBindings method that will recursively unregister from the view model all bindings
    (value and property) that correspond to a framework element and its descendants.

Rebinding

    The problem is that bindings are established using the tokens from the viewmodel.  So it is currently
    impossible to create a binding for which the token doesn't exist (and this same issue would be a problem
    when any intermeidate binding context isn't represented by a token).

	If "resolved binding" (taking into consideration the binding context, which can include binding tokens) exists
	at the time of initial binding, a valid path can be constructed.  If not, this binding would have to be 
	re-attempted each time the client view model changes (from the server?) to see if the binding can then be
	established.  Do we really need to support that (binding contexts that aren't available in the initial state)?

        - What if a control binds to an item that is not present on the origina view model, but shows up later?
        - What if a control binds to an item on the view model, and that item goes away later?
	
	Investigate maintaining path/parentage on replaced tokens.
	How do binding tokens ($root, $parent, etc) fit in to this?

	For array bindings, update repeated items (remove all and re-add?), use stored template to create items (?)

On server 
    Persistent client state
        Use cookies?  homegrown cookie-like method?.  Needs to work with any driver.
    Cache
        View cache - negotiate view cache state so that server knows whether you need a given view or have it
    Hotloading (test for new, later will always load/hotload as needed)

Property binding expressions/directives:

	Negation using !, such as visibility="{!isVisible}"
	One time using ^

    Real expression support:

		Mathematical (240 - charCount)
		Logical (charCount >= 240)
		Type conversion (str(240 - charCount))

Controls - http://msdn.microsoft.com/en-us/library/windows/apps/hh465351.aspx

	AppBar/CommandBar and buttons (app bar button for round app bar buttons that can be used anywhere)

	Border

	Canvas (child elements have positioning properties)

		{ type: "canvas", contents: [
		    { type: "text", value: "Somevalue", top: 10, left: 25 },
		] };

	Checkbox/radio buttons

	Dropdown combo

	Date/time

	Flip view

	Flyout (not really a control)

	Grid / VariableSizeWrapGrid (child elements have row/col properties)

		{ type: "grid", columns: [100, 100], rows: [50, 50], contents: [
		    { type: "text", value: "Somevalue", row: 1, column: 1 },
		] };

	GridView/ListView

	Hub

	Media

	Progress bar / slider (both "range" controls with similar interface)

	Progress ring

	Semantic zoom

	Web view

	Windows contracts?  Sharing, settings, search...
