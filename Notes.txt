
Mobile Application As A Service (MAAAS) - Client
=================================================

List binding attributes

    "items" - context for list of items - should be an array
    "item"  - binding for individual list item (by default, just array element - $data?)
    "itemValue" ? (equiv of itemTemplate) Property Value spec for item string construction - {$index - $last, $first}
    "selection" 
    "selectionItem"

    ToDo - implement item/selectionItem, generally refactor to work like ListView


ListView binding attributes

    "items" binding - the array of elements to add to the list view.
    "item" binding - a path applied to each "items" element to determine the context to be added to list view (defaults to $data).  This allows for the list
        view item to be a context other than the top-level enumerated element.
    "itemTemplate" - layout specification for each item (must be a single element, though that element can be a container that contains other layout elements). 

    "selection" binding - indicated an array to synchronize the selected item/items

    "selectionItem" (defaults to $data) - This is what is placed into "selection" (per item) and this is applied to each item in "items" for the purpose
    of matching list view item with selection items when setting selection state for the list view.  For example, if the selectionItem was "{itemId}", then the
    selection binding would be one or more elements of the "{itemId}" applied to the selected items.  When resetting item selection, "{itemId}" will be applied
    to each list item, and the result will be compared with the value(s) in "selection" to see if the item should be selected.  In the case of the default, the
    selection list will contain deep copies of the list view items, and the selection comparison will be a deep compare of those items with the list view items.

    "onItemClick" command


    ToDo - What about list view header/footer (sections before/after the items)?

    Example (onItemClicked):

        { type: "listview", select: "none", binding: { items: "contacts", selection: "selectedContacts", onItemClick: { command: "itemClicked", item: "{$data}" } }, itemTemplate:
            { type: "stackpanel", orientation: "horizontal", contents: [
                { type: "image", resource: "resources/user.png", height: 50, width: 50 },
                { type: "stackpanel", orientation: "vertical", contents: [
                    { type: "text", value: "{first}" },
                    { type: "text", value: "{last}" },
                ] },
            ] },
        },

        exports.Commands = 
        {
            itemClicked: function(context, session, viewModel, params)
            {
                console.log("Item clicked, first name: " + params.item.first + ", last name: " + params.item.last);
            },
        }

Rebinding

    Note: I'm pretty sure this all got fixed - verify

    The problem is that bindings are established using the tokens from the viewmodel.  So it is currently
    impossible to create a binding for which the token doesn't exist (and this same issue would be a problem
    when any intermeidate binding context isn't represented by a token).

	If "resolved binding" (taking into consideration the binding context, which can include binding tokens) exists
	at the time of initial binding, a valid path can be constructed.  If not, this binding would have to be 
	re-attempted each time the client view model changes (from the server?) to see if the binding can then be
	established.  Do we really need to support that (binding contexts that aren't available in the initial state)?

        - What if a control binds to an item that is not present on the origina view model, but shows up later?
        - What if a control binds to an item on the view model, and that item goes away later?
	
	Investigate maintaining path/parentage on replaced tokens.
	How do binding tokens ($root, $parent, etc) fit in to this?

	For array bindings, update repeated items (remove all and re-add?), use stored template to create items (?)

On server 
    Persistent client state
        Use cookies?  homegrown cookie-like method?.  Needs to work with any driver.
    Cache
        View cache - negotiate view cache state so that server knows whether you need a given view or have it
    Hotloading (test for new, later will always load/hotload as needed)


Binding context specifiers

    Each item has a binding context, which is determined before the item is created/processed by inspecting the
    "binding" attribute to look for a "foreach" or "with" binding context specifier.

        foreach: "foos" (for each element in array "foos", create an instance of this visual element and set the
                         binding context for the visual element to the array element).

        with: "foo.bar" (select the element foo.bar from the current binding context as then new binding context
                         for the visual element).

        Note that it is possible to use "foreach" and "with" together - in which case "foreach" is applied first
        and "with" is applied to each element in the foreach array.  This allows for path navigation both up to,
        and then after, the context to be iterated.


Property binding expressions/directives:

	Negation using !, such as visibility="{!isVisible}"
	One time using ^ (default is one way binding)

    Real expression support:

		Mathematical (240 - charCount)
		Logical (charCount >= 240)
		Type conversion (str(240 - charCount))

Controls - http://msdn.microsoft.com/en-us/library/windows/apps/hh465351.aspx

	AppBar/CommandBar and buttons (app bar button for round app bar buttons that can be used anywhere)

	Border

	Canvas (child elements have positioning properties)

		{ type: "canvas", contents: [
		    { type: "text", value: "Somevalue", top: 10, left: 25 },
		] };

	Checkbox/radio buttons

	Dropdown combo

	Date/time

	Flip view

	Flyout (not really a control)

	Grid / VariableSizeWrapGrid (child elements have row/col properties)

		{ type: "grid", columns: [100, 100], rows: [50, 50], contents: [
		    { type: "text", value: "Somevalue", row: 1, column: 1 },
		] };

	GridView/ListView

	Hub

	Media

	Progress bar / slider (both "range" controls with similar interface)

	Progress ring

	Semantic zoom

	Web view

	Windows contracts?  Sharing, settings, search...

    Stepper (up/down)

    SplitView (maybe only for landscape-first devices, fallback to multi-view for portrait-first)

Containers

    Border
       - Should be done on all platforms.  
       - Make test harness that binds borderthickness and padding and animates them.  Also test animating size of contained control.
       - Support explicit size with content alignment (h and v)?  Maybe later.

    Add "page" scrollers to Android/WinPhone (Win?) like iOS (for cases where content goes off bottom of screen)

    Stack panel - implement/test on all platforms
      - Specify height/width vs wrap content
      - Alignment of items (left/right/center/stretch)
      - Padding

    Slider
      - Orientaton - implement/verify on all platforms

Misc

    Color spec should suppost 8 byte form with alpha specified
    Separate binding ability of RGBA elements would be a neat parlor trick (maybe later)
    Which controls should support "padding"?  Button, Textblock, Textbox?
